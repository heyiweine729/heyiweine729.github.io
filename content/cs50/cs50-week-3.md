---
title: "CS50 学习日志：Week 3 - 算法与效率的艺术"
date: 2026-02-18T21:22:00+08:00
draft: false
author: "Sanjin"
summary: "从线性查找到二分查找，从冒泡排序到归并排序。理解大O表示法，掌握衡量代码效率的数学语言。"
tags: ["CS50", "Algorithm", "Big O", "Sorting"]
categories: ["Study Logs"]
---

# CS50 学习日志：Week 3 - 算法与效率的艺术

> 学习进度：已完成
> 关键主题：大O表示法、排序、查找、递归

---

## ⚡ 核心概览：不仅要对，还要快
*状态：已掌握*

在 Week 3，我意识到计算机虽然计算速度很快，但并非无限快。当处理的数据量从 10 个增加到 1000 万个时，代码的写法将决定程序是“瞬间完成”还是“卡死崩溃”。

这一章的核心在于**算法 (Algorithms)** —— 解决问题的具体步骤，以及如何用数学语言衡量这些步骤的优劣。

### 🔑 关键概念 (Key Concepts)

1.  **Searching (查找算法)**
    * **Linear Search (线性查找)**: 最直观的方法，从头找到尾。虽然简单，但效率较低 ($O(n)$)。
    * **Binary Search (二分查找)**: 也就是“折半查找”。通过每次排除一半的可能性，极大提高了效率 ($O(\log n)$)，但前提是**数组必须是已排序的**。

2.  **Sorting (排序算法)**
    * 为了使用二分查找，我们必须先让数据有序。
    * **Bubble Sort (冒泡排序)** & **Selection Sort (选择排序)**: 易于理解但效率较低 ($O(n^2)$) 的基础排序。
    * **Merge Sort (归并排序)**: 利用递归实现的更高效排序算法 ($O(n \log n)$)。

3.  **Asymptotic Notation (渐进符号)**
    * 我学会了不再用“秒”来衡量速度，而是用**步骤数量的增长趋势**来衡量。
    * **Big O ($O$)**: 最坏情况下的时间复杂度（上限）。
    * **Omega ($\Omega$)**: 最好情况下的时间复杂度（下限）。
    * **Theta ($\Theta$)**: 当最好和最坏情况的量级相同时使用。

4.  **Recursion (递归)**
    * 函数调用其自身。这是理解归并排序 (Merge Sort) 的关键，也是一种优雅（但也容易导致栈溢出）的编程思维。

---

## 📺 补充学习资源 (Shorts)
*来源：Week 3 课程资料*

讲座中展示了震撼的算法可视化演示，而 Shorts 则帮我逐一拆解了每个算法的代码实现细节：

* **Linear Search & Binary Search**: 两种查找方式的直观对比。
* **Bubble Sort & Selection Sort**: 基础排序的逐行代码解析。
* **Recursion (递归)**: 这一概念通常很难理解，Shorts 的解释非常关键。
* **Merge Sort (归并排序)**: 深入理解“分而治之” (Divide and Conquer) 的策略。
---
[[cnote]]